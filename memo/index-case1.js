(function () { const t = document.createElement("link").relList; if (t && t.supports && t.supports("modulepreload")) return; for (const $ of document.querySelectorAll('link[rel="modulepreload"]')) o($); new MutationObserver($ => { for (const r of $) if (r.type === "childList") for (const u of r.addedNodes) u.tagName === "LINK" && u.rel === "modulepreload" && o(u) }).observe(document, { childList: !0, subtree: !0 }); function e($) { const r = {}; return $.integrity && (r.integrity = $.integrity), $.referrerPolicy && (r.referrerPolicy = $.referrerPolicy), $.crossOrigin === "use-credentials" ? r.credentials = "include" : $.crossOrigin === "anonymous" ? r.credentials = "omit" : r.credentials = "same-origin", r } function o($) { if ($.ep) return; $.ep = !0; const r = e($); fetch($.href, r) } })(); const en = { $tag: 0 }; function M(n) { this._0 = n } M.prototype.$tag = 1; function x(n) { this._0 = n } x.prototype.$tag = 0; class $n extends Error { } function J() { throw new $n } function on(n, t) { if (t < 0 || t >= n.length) throw new Error("Index out of bounds") } function g(n) { this._0 = n } g.prototype.$tag = 0; function F(n) { this._0 = n } F.prototype.$tag = 1; const rn = { $tag: 1 }, C = { $tag: 0 }, cn = (n, t) => n.toString(t), K = (n, t) => { n.push(t) }, un = (n, t) => { n.length = t }, h = (n, t, e) => n[t](...e), sn = n => n == null, ln = () => ({}), y = (n, t, e) => { n[t] = e }, an = { $tag: 0 }; function G(n) { this._0 = n } G.prototype.$tag = 1; const w = () => document, dn = (n, t) => n.createElement(t), Q = (n, t) => n.createTextNode(t); function U(n) { this._0 = n } U.prototype.$tag = 0; function N(n) { this._0 = n } N.prototype.$tag = 1; const _n = (n, t, e) => n.addEventListener(t, e), L = (n, t) => (n.click = t, n), mn = n => Object.entries(n).map(([t, e]) => ({ _0: t, _1: { $tag: 2, _0: e } })), z = { $tag: 0 }; function v(n) { this._0 = n } v.prototype.$tag = 1; const f = { $tag: 0 }, b = { $tag: 0 }, j = { method_0: wn, method_1: Sn, method_2: X, method_3: pn }, D = { val: 0 }, m = { current_subscriber: void 0, current_cleanups: en }, fn = "container", bn = "count"; function hn(n, t) { return n !== 0 } function O(n) { return { val: "" } } function pn(n, t) { const e = n; e.val = `${e.val}${String.fromCodePoint(t)}` } function gn(n, t) { return !hn(n) } function yn(n, t) { const e = n.length; return t >= 0 && t < e ? (on(n, t), n[t]) : J() } function wn(n, t) { const e = n; e.val = `${e.val}${t}` } function zn(n, t, e) { const o = n.length; let $; if (e === void 0) $ = o; else { const i = e; $ = i < 0 ? o + i | 0 : i } const r = t < 0 ? o + t | 0 : t; if (r >= 0 && r <= $ && $ <= o) { let u; if (r < o) { const s = n.charCodeAt(r); u = 56320 <= s && s <= 57343 } else u = !1; if (u) return new g(C); let i; if ($ < o) { const s = n.charCodeAt($); i = 56320 <= s && s <= 57343 } else i = !1; return i ? new g(C) : new F({ str: n, start: r, end: $ }) } else return new g(rn) } function Sn(n, t, e, o) { let $; n: { t: { const r = zn(t, e, e + o | 0); if (r.$tag === 1) $ = r._0; else { r._0; break t } break n } $ = J() } X(n, $) } function vn(n) { const t = O(), e = { self: t, method_table: j }; return n ? e.method_table.method_0(e.self, "true") : e.method_table.method_0(e.self, "false"), t.val } function An(n) { const t = O(); return In(n, { self: t, method_table: j }), t.val } function En(n) { const t = O(); return rt(n, { self: t, method_table: j }), t.val } function W(n, t) { return cn(n, t) } function xn(n) { return n.str.substring(n.start, n.end) } function Nn(n) { return n() } function jn(n) { return t => { for (; ;) { const e = Nn(n); if (e === void 0) return 1; if (t(e) !== 1) return 0 } } } function X(n, t) { const e = n; e.val = `${e.val}${xn(t)}` } function p(n, t) { K(n, t) } function On(n, t) { K(n, t) } function kn(n, t) { return n(t) } function In(n, t) { t.method_table.method_0(t.self, W(n, 10)) } function Cn(n) { const t = { val: 0 }; return () => { if (t.val < (n.end - n.start | 0)) { const o = n.buf[n.start + t.val | 0]; return t.val = t.val + 1 | 0, o } else return } } function Ln(n) { return Cn({ buf: n, start: 0, end: n.length }) } function Dn(n) { return jn(Ln(n)) } function Bn(n, t) { return gn(kn(n, e => t(e) ? 0 : 1)) } function Tn(n) { console.log(n) } function Pn(n, t) { un(n, t) } function qn(n) { Pn(n, 0) } function Hn(n) { return sn(n) ? an : new G(n) } function Y(n, t) { return h(n, "appendChild", [t]) } function Rn(n, t) { y(n, "textContent", t) } function Vn(n, t) { y(n, "className", t) } function A(n, t, e) { h(n, "setAttribute", [t, e]) } function Mn(n, t) { h(n, "removeAttribute", [t]) } function Jn(n, t) { const e = h(n, "getElementById", [t]); return Hn(e) } function Fn() { const n = D.val; return D.val = n + 1 | 0, n } function B(n) { let t = n.length - 1 | 0; for (; ;) { const e = t; if (e >= 0) { yn(n, e)(), t = e - 1 | 0; continue } else break } qn(n) } function Kn(n) { const t = m.current_cleanups; return m.current_cleanups = n, t } function Gn(n, t) { const e = Kn(new M(n)); t(), m.current_cleanups = e } function Qn(n, t) { const e = m.current_subscriber; m.current_subscriber = n, t(), m.current_subscriber = e } function Z(n) { const t = { active: !0, cleanups: [] }, e = Fn(), o = { val: void 0 }, $ = () => { if (!t.active) return; B(t.cleanups); const i = o.val; if (i !== void 0) { Qn(i, () => { Gn(t.cleanups, n) }); return } }, r = { id: e, run: $ }; return o.val = r, $(), () => { t.active = !1, B(t.cleanups) } } function E(n) { const t = m.current_subscriber; if (t !== void 0) { const o = t; Bn(Dn(n.subscribers), r => r.id === o.id) || On(n.subscribers, o) } return n.value } function Un(n) { return { value: n, subscribers: [] } } function Wn(n) { { const t = n.run; t(); return } } function Xn(n) { const t = n.subscribers, e = t.length; let o = 0; for (; ;) { const $ = o; if ($ < e) { const r = t[$]; Wn(r), o = $ + 1 | 0; continue } else return } } function T(n, t) { n.value = t, Xn(n) } function Yn(n) { const t = w(), e = n(), o = Q(t, e); return Z(() => { const $ = n(); Rn(o, $) }), new N(o) } function Zn(n) { return Yn(() => An(E(n))) } function P(n, t, e) { if (t === "className") { Vn(n, e); return } else if (t === "value") { y(n, "value", e); return } else if (t === "checked") { y(n, "checked", e === "true"); return } else if (t === "disabled") if (e === "true") { A(n, "disabled", ""); return } else { Mn(n, "disabled"); return } else { A(n, t, e); return } } function q(n, t) { A(n, "style", t) } function nt(n, t, e) { switch (e.$tag) { case 0: { const $ = e._0; if (t === "style") { q(n, $); return } else { P(n, t, $); return } } case 1: { const $ = e._0; Z(() => { const r = $(); if (t === "style") { q(n, r); return } else { P(n, t, r); return } }); return } default: { const $ = e._0; if (t === "__ref") { $(n); return } else { _n(n, t, $); return } } } } function tt(n) { return { inner: n } } function nn(n) { switch (n.$tag) { case 0: return n._0.inner; case 1: return n._0; default: return n._0 } } function k(n, t, e) { const o = w(), $ = dn(o, n), r = t.length; let u = 0; for (; ;) { const c = u; if (c < r) { const l = t[c], d = l._0, a = l._1; nt($, d, a), u = c + 1 | 0; continue } else break } const i = e.length; let s = 0; for (; ;) { const c = s; if (c < i) { const l = e[c]; Y($, nn(l)), s = c + 1 | 0; continue } else break } return new U(tt($)) } function et(n, t) { Y(n, nn(t)) } function $t(n) { const t = w(); return new N(Q(t, n)) } function ot(n) { return h(n, "toString", []) } function rt(n, t) { switch (n.$tag) { case 0: { const o = n._0; t.method_table.method_0(t.self, o); return } case 1: { const o = n._0; t.method_table.method_0(t.self, ot(o)); return } case 2: { const o = n._0; t.method_table.method_0(t.self, W(o, 10)); return } default: { const o = n._0; t.method_table.method_0(t.self, vn(o)); return } } } function it(n) { return new x(En(n)) } function H() { return ln() } function I(n, t, e, o, $, r, u) { const i = []; if (t !== void 0) { const c = t; p(i, { _0: "className", _1: new x(c) }) } if (o.$tag === 1) { const c = o._0, l = mn(c), d = l.length; let a = 0; for (; ;) { const _ = a; if (_ < d) { const tn = l[_]; p(i, tn), a = _ + 1 | 0; continue } else break } } if (r.$tag === 1) { const c = r._0, l = c.length; let d = 0; for (; ;) { const a = d; if (a < l) { const _ = c[a]; p(i, { _0: _._0, _1: it(_._1) }), d = a + 1 | 0; continue } else break } } if (u.$tag === 1) { const c = u._0, l = c.length; let d = 0; for (; ;) { const a = d; if (a < l) { const _ = c[a]; p(i, _), d = a + 1 | 0; continue } else break } } return i } function R(n, t, e, o, $, r, u, i, s, c) { const l = I(n, t, e, r, u, i, s); return k("div", l, c) } function ct(n, t, e, o, $, r, u, i, s, c) { const l = I(n, t, e, r, u, i, s); return k("h1", l, c) } function V(n, t, e, o, $, r, u, i, s, c, l, d) { const a = I(t, e, o, i, s, c, l); return k("button", a, d) } function S(n) { return $t(n) } function ut(n) { return Zn(n) } (() => { const n = Un(0), t = R(void 0, fn, void 0, void 0, void 0, z, void 0, f, b, [ct(void 0, void 0, void 0, void 0, void 0, z, void 0, f, b, [S("Counter")]), R(void 0, bn, void 0, void 0, void 0, z, void 0, f, b, [ut(n)]), V(-1, void 0, void 0, void 0, void 0, void 0, void 0, new v(L(H(), o => { T(n, E(n) + 1 | 0) })), void 0, f, b, [S("+")]), V(-1, void 0, void 0, void 0, void 0, void 0, void 0, new v(L(H(), o => { T(n, E(n) - 1 | 0) })), void 0, f, b, [S("-")])]), e = Jn(w(), "app"); if (e.$tag === 1) { const $ = e._0; et($, t); return } else { Tn("Error: #app not found"); return } })();
